head	1.24;
access;
symbols;
locks
	root:1.24; strict;
comment	@ * @;


1.24
date	2012.09.30.07.53.35;	author root;	state Exp;
branches;
next	1.23;

1.23
date	2012.09.30.04.16.09;	author root;	state Exp;
branches;
next	1.22;

1.22
date	2012.09.29.21.25.45;	author root;	state Exp;
branches;
next	1.21;

1.21
date	2012.09.28.22.43.56;	author root;	state Exp;
branches;
next	1.20;

1.20
date	2012.09.26.21.23.27;	author root;	state Exp;
branches;
next	1.19;

1.19
date	2012.09.26.17.38.12;	author cjmoore;	state Exp;
branches;
next	1.18;

1.18
date	2012.09.25.19.37.26;	author cjmoore;	state Exp;
branches;
next	1.17;

1.17
date	2012.09.23.21.40.42;	author cjmoore;	state Exp;
branches;
next	1.16;

1.16
date	2012.09.23.21.13.08;	author cjmoore;	state Exp;
branches;
next	1.15;

1.15
date	2012.09.22.23.45.23;	author cjmoore;	state Exp;
branches;
next	1.14;

1.14
date	2012.09.19.18.47.37;	author cjmoore;	state Exp;
branches;
next	1.13;

1.13
date	2012.09.19.18.22.13;	author cjmoore;	state Exp;
branches;
next	1.12;

1.12
date	2012.09.19.05.41.22;	author cjmoore;	state Exp;
branches;
next	1.11;

1.11
date	2012.09.19.04.26.00;	author cjmoore;	state Exp;
branches;
next	1.10;

1.10
date	2012.09.19.03.57.00;	author cjmoore;	state Exp;
branches;
next	1.9;

1.9
date	2012.09.19.03.32.11;	author cjmoore;	state Exp;
branches;
next	1.8;

1.8
date	2012.09.19.02.33.10;	author cjmoore;	state Exp;
branches;
next	1.7;

1.7
date	2012.09.18.19.27.21;	author cjmoore;	state Exp;
branches;
next	1.6;

1.6
date	2012.09.18.17.39.44;	author cjmoore;	state Exp;
branches;
next	1.5;

1.5
date	2012.09.18.16.08.43;	author cjmoore;	state Exp;
branches;
next	1.4;

1.4
date	2012.09.17.21.39.13;	author cjmoore;	state Exp;
branches;
next	1.3;

1.3
date	2012.09.17.19.51.52;	author cjmoore;	state Exp;
branches;
next	1.2;

1.2
date	2012.09.17.02.10.05;	author cjmoore;	state Exp;
branches;
next	1.1;

1.1
date	2012.09.16.21.52.47;	author cjmoore;	state Exp;
branches;
next	;


desc
@Main Blowfish Cipher Encypt/Decrypt Tool C-File
@


1.24
log
@Finished STDIN and STDOUT
@
text
@#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include "blowfish.h"

/* Handles checking if file exists
 * as well as proper permissions on file
 * SUCCESS CODE(S):
 * 0 = Success (File DOES NOT exist)
 * ERROR CODE(S):
 * 1 = File does exist
 * 2 = File does exist & no permissions
 */
int fileExists(char *fName){
  struct stat buf;
  errno=0;
  int chk = stat(fName, &buf);
  if(errno!=0){
  	return (chk==0);
	} else {
		return 2;
	}
}

/* Handles checking if path is directory
 * SUCCESS CODE(S):
 * 0 = Success (Path is NOT a directory)
 * ERROR CODE(S):
 * 1 = Path is a directory
 * 2 = Out of memory
 */
int isDirectory(char *path){
  struct stat *buf;
  buf = (struct stat*)malloc(sizeof(struct stat));
  if(buf==NULL){
  	free(buf);
  	return 2;
  }
  stat(path,buf);
  if(buf->st_mode & S_IFDIR){
  	free(buf);
    return 0;
  } else {
  	free(buf);
    return 1;
  }
}

/* Handles checking if the given path of a file
 * is pointing to a regular file.
 * (NOTE: If path is a symlink
 * follow it to find a regular file.)
 * SUCCESS CODE(S):
 * 0 = Success (Path points to regular file)
 * ERROR CODE(S):
 * 1 = Path is a character device
 * 2 = Path is a block device
 * 3 = Path is a named pipe
 * 4 = Path is a socket
 * 5 = Path is a directory
 * 6 = Path is a symlink
 */
int isRegularFile(char *path){
	struct stat *buf;
	buf = (struct stat*)malloc(sizeof(struct stat));
	stat(path,buf);
	if(buf->st_mode & S_IFREG){
		free(buf);
		return 0;
	} else if(buf->st_mode & S_IFCHR){
		free(buf);
		return 1;
	} else if(buf->st_mode & S_IFBLK){
		free(buf);
		return 2;
	} else if(buf->st_mode & S_IFIFO){
		free(buf);
		return 3;
	} else if(buf->st_mode & S_IFSOCK){
		free(buf);
		return 4;
	} else if(buf->st_mode & S_IFDIR){
		free(buf);
		return 5;
	} else{
		free(buf);
		return 6;
	}
}

/* Handles checking if two files are the same.
 * This method assumes the files exist.
 * (checks for symlinks and hardlinks)
 * SUCCESS CODE(S):
 * 0 = Success (NOT the same file) 
 * ERROR CODE(S):
 * 1 = Paths are the same (same referencing)
 * 2 = Hardlinks to same file
 * 3 = In/Out symlinks point to same file
 * 4 = Input symlink points to outfile
 * 5 = Output symlink points to infile
 */
int isSameFiles(char *in_path, char *out_path){
	struct stat *in_buffer;
	struct stat *out_buffer;
	in_buffer = (struct stat*)malloc(sizeof(struct stat));
	out_buffer = (struct stat*)malloc(sizeof(struct stat));
	stat(in_path,in_buffer);
	stat(out_path,out_buffer);
	// Checks if the basic paths are the same
	if(strcmp(in_path,out_path)==0){
		free(in_buffer); free(out_buffer);
		return 1;
	} else {
		// Check if either are symlinks
		lstat(in_path,in_buffer);
		lstat(out_path,out_buffer);
		if(!(in_buffer->st_mode & S_IFLNK) 
		&& !(out_buffer->st_mode & S_IFLNK)){
			// If both are not links then check to be SURE they are same file
			//  (Aka Hardlinks to same file)
			if((in_buffer->st_dev==out_buffer->st_dev) 
			&& (in_buffer->st_ino==out_buffer->st_ino)){
				free(in_buffer); free(out_buffer);
				return 2;
			} else {
				// They must be pointing to two different files
				// (Not Hardlinks)
				free(in_buffer); free(out_buffer);
				return 0;
			}
		} else if((in_buffer->st_mode & S_IFLNK) 
		&& (out_buffer->st_mode & S_IFLNK)){
			// Both input file & output file are symlinks
			// Check if they point to the same file
			stat(in_path,in_buffer);
			stat(out_path,out_buffer);
			if((in_buffer->st_dev==out_buffer->st_dev) 
			&& (in_buffer->st_ino==out_buffer->st_ino)){
				free(in_buffer); free(out_buffer);
				return 3;
			} else {
				free(in_buffer); free(out_buffer);
				return 0;
			}
		} else if((in_buffer->st_mode & S_IFLNK) 
		&& !(out_buffer->st_mode & S_IFLNK)){
			// Only the input file is a symlink
			// Check if input points to output
			stat(in_path,in_buffer);
			stat(out_path,in_buffer);
			if((in_buffer->st_dev==out_buffer->st_dev) 
			&& (in_buffer->st_ino==out_buffer->st_ino)){
				free(in_buffer); free(out_buffer);
				return 4;
			} else {
				free(in_buffer); free(out_buffer);
				return 0;
			}
		} else {
			// Only the output file is a symlink
			// Check if output points to input
			stat(in_path,in_buffer);
			stat(out_path,out_buffer);
			if((in_buffer->st_dev==out_buffer->st_dev) 
			&& (in_buffer->st_ino==out_buffer->st_ino)){
				free(in_buffer); free(out_buffer);
				return 5;
			} else {
				free(in_buffer); free(out_buffer);
				return 0;
			}
		}
	}
}

/* [-------- Main Method --------]
 * SUCCESS CODE(S):
 * 0 = Encrypt OR Decrypt Successful
 * 1 = Help menu displayed for user
 * 2 = Version displayed for user
 * ERROR CODE(S):
 * 3 = Invalid execution
 * 4 = No <outfile> given
 * 5 = <infile> does not exist
 * 6 = <infile> OR <outfile> is directory
 * 7 = Same file error
 * 8 = File i/o OR permission error
 */
int main(int argc, char *argv[]){
  // 1=Enable Debug Mode
  // 0=Disable Debug Mode
  int DEBUG = 0;
  int i = 0; // General purpose index
  
  /* Initialize from and to buffers to OS pagesize */
  int page_size=getpagesize();
  unsigned char *from;
  unsigned char *to; 

  /* Temp buffer to store user input (user password) */
	const int PASS_MAX = 16;  
	char *temp_pass;
	char *password_final;
  char temp_buf[17];
  char temp_buf_chk[17];
  char rcs_vers[18] = "$Revision: 1.23 $";
  char *rcs_vers_cp,*version;
  int passArgNum = 0;
  
  /* File names/descriptors/stats */
  int infile_fd;
  int outfile_fd;
  char *infile_name;
  char *outfile_name;
  int stdin_bool;
  int stdout_bool;
  int sf_code;
  int bytes_read;
  int bytes_write;

  /* Define boolean ints for params */
  int deco, enco, vers, help, mmap, pass, opt, safe;
  
  /* don't worry about these two: just define/use them */
  int n = 0;  /* internal blowfish variables */
  unsigned char iv[8];  /* Initialization Vector */
  
  /* Define a structure to hold the key */
  BF_KEY key;
  
  /* Parse out version properly for display */
  rcs_vers_cp = strdup(rcs_vers);
  version = strtok(rcs_vers_cp," ");
  version = strtok(NULL," ");
  free(rcs_vers_cp);
  
  /* fill the IV with zeros (or any other fixed data) */
  memset(iv, 0, 8);
  
  /* clear buffers */
  memset(temp_buf,0,17);
  memset(temp_buf_chk,0,17);
  
  /* Initialize and check params */
  stdin_bool = 0; stdout_bool = 0; errno = 0;
  deco = 0; enco = 0; vers = 0; help = 0; mmap = 0; pass = 0; safe = 0;
  while((opt = getopt(argc, argv, "devhmsp:")) != -1) {
    switch(opt){
    case 'd':
      deco = 1;
      break;
    case 'e':
      enco = 1;
      break;
    case 'v':
      vers = 1;
      break;
    case 'h':
      help = 1;
      break;
    case 'm':
      mmap = 1;
      break;
    case 's':
      safe = 1;
      break;
    case 'p':
    	if(strlen(optarg) > PASS_MAX){
    		fprintf(stderr,"Error Code 3: Invalid Execution\n");
    		fprintf(stderr,"Password cannot exceed 16 characters.\n");
    		exit(3);
    	} else {
      	strcpy(temp_buf, optarg);
      	// Gets argc number from optind for comparison
				//  and error checking later
				passArgNum = optind-1;
    	  pass = 1;
      	break;
      }
    default:
    	fprintf(stderr,"Error Code 3: Invalid execution\n");
      fprintf(stderr,"Usage: %s [OPTIONS] [-p PASSWORD] <infile> <outfile>\n", argv[0]);
      exit(3);
    }
  }
  
  // DEBUGGING CODE //
  if(DEBUG==1){
    printf("\n[----- DEBUGGING ENABLED -----]\n");
    printf("To disable, change DEBUG variable in cipher.c from 1 to 0 and remake\n");
    printf("\ndecode=%i \nencode=%i \nversion=%i \nhelp=%i \nmmap=%i \npass=%i \nsafe=%i\n", deco, enco, vers, help, mmap, pass, safe);

    if(pass==1){
      printf("temp_buf=%s \npassArgNum=%i\n",temp_buf,passArgNum);
    } else {
      printf("temp_buf=<BLANK> \npassArgNum=%i\n",passArgNum);
    }
    printf("argc=%i\n",argc);
  }
  ////////////////////
    
  if(help==1){
    printf("Blowfish Cipher Tool by Cody Moore \n");
    printf("Usage: %s [OPTIONS] [-p PASSWORD] <infile> <outfile> \n", argv[0]);
    printf("Options: \n");
    printf("   -p [PASS] :  Use [PASS] as password (skip prompt) \n");
    printf("   -d        :  Decrypt <infile> to <outfile> \n");
    printf("   -e        :  Encrypt <infile> to <outfile> \n");
    printf("   -v        :  Print version number \n");
    printf("   -h        :  Show help screen (you are looking at it) \n");
    printf("   -m        :  Enable memory mapping - mmap() \n");
    printf("   -s        :  Safe Mode (prompt for password twice)\n");
    exit(1);
  } else if(vers==1){
    printf("Blowfish Cipher Tool - v%s\n", version);
    exit(2);
  } else if(argc>=3){
    // Check for proper format of <infile> and <outfile>
    if((strcmp(argv[passArgNum],argv[argc-2])==0) && passArgNum!=0){
      if(DEBUG==1){
        printf("pass=%s \nargc-2=%s \n",argv[passArgNum],argv[argc-2]);
      }
      fprintf(stderr,"Error Code 4: No <outfile> specified\n");
      exit(4);
    }
    // Take <infile> and <outfile>
    infile_name=(char*)malloc(strlen(argv[argc-2]));
    outfile_name=(char*)malloc(strlen(argv[argc-1]));
    strcpy(outfile_name, argv[argc-1]);
		strcpy(infile_name, argv[argc-2]);
		
    // Check if stdout or stdin is used
    //  in replace of <infile> or <outfile>
    if(strcmp(infile_name,"-")==0){
      stdin_bool=1;
    }
    if(strcmp(outfile_name,"-")==0){
      stdout_bool=1;
    }
    
    // ----- <infile> Error Checking -----
    // (Only if <infile> is NOT set to STDIN)
    if(stdin_bool!=1){
    	i=fileExists(infile_name);
      if(i==0){
        // <infile> DOES NOT exist
        fprintf(stderr,"Error Code 5: <infile> does not exist\n");
        free(infile_name);
        free(outfile_name);
        exit(5);
      } else if(i==2){
      	// <infile> DOES exist
      	// Is it a directory?
      	if((isDirectory(infile_name))!=1){
      		// <infile> DOES exist AND is a directory
        	fprintf(stderr,"Error Code 6: <infile> is a directory\n");
        	free(infile_name);
       		free(outfile_name);
      	  exit(6);
      	}
      } else {
      	// <infile> DOES exist AND is NOT a directory
      }
    }
    // Postconditions:
    // <infile> DOES exist and IS NOT a directory
    // OR <infile> is set to STDIN
    // with no i/o or permission errors
    
    // ----- <outfile> Error Checking -----
    // (Only if <outfile> is NOT set to STDOUT)
    if(stdout_bool!=1){
    	if((fileExists(outfile_name))!=1){
    		// <outfile> DOES NOT exist
    		// do nothing - possible error caught
    		// when calling open later on.
    	} else if((isDirectory(outfile_name))!=1){
    		// <outfile> DOES exist AND is directory
    		fprintf(stderr,"Error Code 6: <outfile> is a directory\n");
    		free(infile_name);
    		free(outfile_name);
    		exit(6);
    	} else {
    		// <outfile> DOES exist AND is NOT a directory
    		fprintf(stderr, "Warning: <outfile> exists, overwritting...\n");
    	}
    }
    // Postconditions:
    // <outfile> IS NOT a directory AND exists (either made or overwrote)
    // OR <outfile> is set to STDOUT
    
    if(stdin_bool==0 && stdout_bool==0){
    	// Check if infile and outfile are the same
    	sf_code = isSameFiles(infile_name, outfile_name);
    	if(sf_code==1){
    		// Paths are the same references
    		fprintf(stderr,"Error Code 7: <infile> and <outfile> are the same path\n");
    		free(infile_name);
    		free(outfile_name);
    		exit(7);
    	} else if(sf_code==2){
    		// Hardlinks to same file
    		fprintf(stderr,"Error Code 7: <infile> and <outfile> are hardlinks to same file\n");
    		free(infile_name);
    		free(outfile_name);
    		exit(7);
   	 } else if(sf_code==3){
 	   		// In/Out symlinks point to same file
 	   		fprintf(stderr,"Error Code 7: <infile> and <outfile> are symlinks to same file\n");
    		free(infile_name);
    		free(outfile_name);
    		exit(7);
    	} else if(sf_code==4){
    		// Input symlink points to outfile
    		fprintf(stderr,"Error Code 7: <infile> symlink points to <outfile>\n");
    		free(infile_name);
    		free(outfile_name);
    		exit(7);
    	} else if(sf_code==5){
    		// Output symlink points to infile
    		fprintf(stderr,"Error Code 7: <outfile> symlink points to <infile>\n");
    		free(infile_name);
   	 		free(outfile_name);
  	  	exit(7);
  	  } else{
  	  	// No error, continue on
 	  	}
    }
    
    // Check if <infile> or <outfile> is a char/block special device
    if(stdin_bool!=1){
   		switch(isRegularFile(infile_name)){
    		case 0:
    			// Regular File
    			break;
    		case 1:
    			// Character Device
    			fprintf(stderr,"Error Code 7: <infile> is a character device\n");
    			free(infile_name);
    			free(outfile_name);
    			exit(7);
    		case 2:
    			// Block Device
    			fprintf(stderr,"Error Code 7: <infile> is a block device\n");
    			free(infile_name);
    			free(outfile_name);
    			exit(7);
    		case 3:
    			// FIFO - Named Pipe
    			fprintf(stderr,"Error Code 7: <infile> is a named pipe\n");
    			free(infile_name);
    			free(outfile_name);
    			exit(7);
    		case 4:
    			// Socket
    			fprintf(stderr,"Error Code 7: <infile> is a socket\n");
    			free(infile_name);
    			free(outfile_name);
    			exit(7);
    		case 5:
    			// Directory
    			fprintf(stderr,"Error Code 7: <infile> is a directory\n");
    			free(infile_name);
    			free(outfile_name);
    			exit(7);
    	}
    }
    if(stdout_bool!=1){
    	switch(isRegularFile(outfile_name)){
    		case 0:
    			// Regular File
    			break;
    		case 1:
    			// Character Device
    			fprintf(stderr,"Error Code 7: <outfile> is a character device\n");
    			free(infile_name);
    			free(outfile_name);
    			exit(7);
    		case 2:
    			// Block Device
    			fprintf(stderr,"Error Code 7: <outfile> is a block device\n");
    			free(infile_name);
    			free(outfile_name);
    			exit(7);
    		case 3:
    			// FIFO - Named Pipe
    			fprintf(stderr,"Error Code 7: <outfile> is a named pipe\n");
    			free(infile_name);
    			free(outfile_name);
    			exit(7);
    		case 4:
    			// Socket
    			fprintf(stderr,"Error Code 7: <outfile> is a socket\n");
    			free(infile_name);
    			free(outfile_name);
    			exit(7);
    		case 5:
    			// Directory
    			fprintf(stderr,"Error Code 7: <infile> is a directory\n");
    			free(infile_name);
    			free(outfile_name);
    			exit(7);
    	}
    }
    //	Post-conditions: 
    //	<infile> exists, it is NOT a directory, and if it is a 
    //		symlink/hardlink, it points to a seperate regular file
    //		than <outfile>, else it is not a link but a regular file.
    //	<outfile> may exist, and if it does exist and is a
    //		symlink/hardlink, it points to a seperate regular file
    //		than <infile>, else it is not a link but a regular file.    
    
    // DEBUGGING CODE //
    if(DEBUG==1){
      printf("infile_name=%s\n",infile_name);
      printf("outfile_name=%s\n",outfile_name);
      printf("read from stdin=%i\n",stdin_bool);
      printf("print to stdout=%i\n",stdout_bool);
    }
    ////////////////////
   	
   	// Check for password/safe inputs
   	passArgNum=0; // Re-using var for pass matching
   	password_final=(char*)malloc(PASS_MAX);
   	memset(password_final,0,PASS_MAX);
   	if(pass==1 && safe==0){
   		// temp_buf has password
   		if(DEBUG==1){
   			printf("BEFORE COPY\n");
   			printf("password_final_len=%i\n",strlen(password_final));
   			printf("temp_buf_len=%i\n",strlen(temp_buf));
   		}
   		strcpy(password_final,temp_buf);
   		if(DEBUG==1){
   			printf("AFTER COPY\n");
   			printf("password_final_len=%i\n",strlen(password_final));
   			printf("temp_buf_len=%i\n",strlen(temp_buf));
   		}
   	} else if(pass==0){
   		// Start password matching loop
   		while(passArgNum==0){
   			// Ask for first password
   			if(DEBUG==1){
   				printf("Checking for password..\n");
   			}
   			while(strlen(temp_buf)==0){
   				temp_pass = getpass("Enter Password: ");
   				if((unsigned)strlen(temp_pass) <= 16){
   					strcpy(temp_buf,temp_pass);
   				} else {
   					fprintf(stderr,"Error: Password cannot be longer than 16 characters\n");
   				}
   			}
   			if(DEBUG==1){
   				printf("The 1st password is: %s\r\n",temp_buf);
   			}
   			if(safe==1){
     			// Ask for second password
   				temp_pass = getpass("Confirm Password: ");
   				if((unsigned)strlen(temp_pass) <= 16){
   					strcpy(temp_buf_chk,temp_pass);
   					if(DEBUG==1){
     					printf("The 2nd password is: %s\r\n",temp_buf_chk);
     				}
     				// Do the passwords match?
     				if(strcmp(temp_buf,temp_buf_chk)==0){
     					// Yes! :)
     					passArgNum=1;
     					strcpy(password_final,temp_buf);
     				} else {
     					// No :(
     					passArgNum=0;
     					fprintf(stderr,"Error: Passwords do not match, re-prompting...\n");
     					memset(temp_buf,0,17);
     					memset(temp_buf_chk,0,17);
     				}
   				} else {
   					fprintf(stderr,"Error: Password cannot be longer than 16 characters\n");
   					fprintf(stderr,"Error: Passwords do not match, re-prompting...\n");
   					memset(temp_buf,0,17);
     				memset(temp_buf_chk,0,17);
   				}
     		} else {
     			// No safe statement given, no password to match
     			passArgNum=1;
     			strcpy(password_final,temp_buf);
     		}
     	}
   	} else {
   		// Error both -p and -s given
   		fprintf(stderr,"Error Code 3: Cannot use \'-p\' and \'-s\'\n");
   		free(infile_name);
   		free(outfile_name);
   		exit(3);
   	}
    // temp_buf contains the right password for encryption or decryption
    if(DEBUG==1){
    	printf("password_final= %s \n",password_final);
    }
    password_final[strlen(password_final)]='\0';
    
    /* call this function once to setup the cipher key */
    BF_set_key(&key, PASS_MAX, (unsigned char *)password_final);
    
    /* Open up file descriptors */
    // Open up infile fd
    if(stdin_bool==0){
    	errno=0;
    	infile_fd=open(infile_name, O_RDONLY, S_IREAD);
    	if(DEBUG==1){
    		printf("infile_fd= %i \n",infile_fd);
   	 }
    	if(infile_fd==-1){
    		perror("Error Code 8: On <infile> ");
    		free(infile_name);
    		free(outfile_name);
    		exit(8);
    	}
    } else {
    	infile_fd=STDIN_FILENO;
    }
    
    
    // Open up outfile fd
    if(stdout_bool==0){
    	errno=0;
    	outfile_fd=open(outfile_name, O_WRONLY | O_CREAT | O_TRUNC | O_APPEND, S_IWRITE);
    	if(DEBUG==1){
    		printf("outfile_fd= %i \n",outfile_fd);
    	}
    	if(outfile_fd==-1){
    		perror("Error Code 8: On <outfile> ");
    		free(infile_name);
    		free(outfile_name);
    		exit(8); 
    	}
    } else {
    	outfile_fd=STDOUT_FILENO;
    }
    
    // Initialize to and from and clear them
    to = (unsigned char*)malloc(page_size);
    from = (unsigned char*)malloc(page_size);
    memset(to,0,page_size);
    memset(from,0,page_size);
    
    ///// [---------- DECRYPTION START ----------] /////
    if(deco==1 && enco==0){
    	if(stdout_bool==0){
    		if(stdin_bool==1){
    			printf("Decrypting from STDIN...\n");
    		} else {
    			printf("Decrypting the file: %s \n",infile_name);
    		}
    	}
			// Start reading the bytes of length page_size from infile
			bytes_read = -1;
    	while(bytes_read!=0){
    		bytes_read=read(infile_fd,from,page_size);
    		if(DEBUG==1){
    			printf("\nbytes_read=%i\n",bytes_read);
    		}
    		if(bytes_read==-1){
    			// Maybe partial read encountered?
    			perror("Error Code 8: On <infile> ");
    			free(infile_name);
    			free(outfile_name);
    			close(infile_fd);
    			close(outfile_fd);
    			exit(8);
    		} else if(bytes_read > 0){
    			// Decrypt the buffer
    			BF_cfb64_encrypt(from, to, page_size, &key, iv, &n, BF_DECRYPT);
    			// Was the read even with page_size?
    			if(bytes_read == page_size){
    				// Write buffer
    				bytes_write=write(outfile_fd,to,page_size);
    				if(DEBUG==1){
    					printf("bytes_read == page_size\n");
    					printf("bytes_write=%i\n",bytes_write);
    				}
    				if(bytes_write==-1){
    					// Maybe partial write encountered?
    					perror("Error Code 8: On <outfile> ");
    					free(infile_name);
    					free(outfile_name);
    					close(infile_fd);
    					close(outfile_fd);
    					exit(8);
    				}
    			} else if(bytes_read < page_size){
    				// Last iteration
    				// Write buffer
    				bytes_write=write(outfile_fd,to,bytes_read);
    				if(DEBUG==1){
    					printf("bytes_read < page_size\n");
    					printf("bytes_write=%i\n",bytes_write);
    				}
    				if(bytes_write==-1){
    					// Maybe partial write encountered?
    					perror("Error Code 8: On <outfile> ");
    					free(infile_name);
    					free(outfile_name);
    					close(infile_fd);
    					close(outfile_fd);
    					exit(8);
    				}
    			}
    			// Clear buffers
    			memset(to,0,page_size);
    			memset(from,0,page_size);
    		} // else bytes_read == 0, terminate while
    	}
    if(stdout_bool==0){
    	printf("Saving to: %s \n",outfile_name);
    }
    ///// [---------- DECRYPTION END ----------] /////
    
    ///// [---------- ENCRYPTION START ----------] /////
    } else if(deco==0 && enco==1){
    	if(stdout_bool==0){
    		if(stdin_bool==1){
    			printf("Encrypting from STDIN...\n");
    		} else {
    			printf("Encrypting the file: %s \n",infile_name);
    		}
    	}
    	// Start reading the bytes of length page_size from infile
    	bytes_read=-1;
    	while(bytes_read!=0){
    		bytes_read=read(infile_fd,from,page_size);
    		if(DEBUG==1){
    			printf("\nbytes_read=%i\n",bytes_read);
    		}
    		if(bytes_read==-1){
    			// Maybe partial read encountered?
    			perror("Error Code 8: On <infile> ");
    			free(infile_name);
    			free(outfile_name);
    			close(infile_fd);
    			close(outfile_fd);
    			exit(8);
    		} else if(bytes_read > 0){
    			// Encrypt the buffer
    			BF_cfb64_encrypt(from, to, page_size, &key, iv, &n, BF_ENCRYPT);
    			// Was the read even with page_size?
    			if(bytes_read == page_size){
    				// Write buffer
						bytes_write=write(outfile_fd,to,page_size);
    				if(DEBUG==1){
    					printf("bytes_read == page_size\n");
    					printf("bytes_write=%i\n",bytes_write);
    				}
    				if(bytes_write==-1){
    					// Maybe partial write encountered?
    					perror("Error Code 8: On <outfile> ");
    					free(infile_name);
    					free(outfile_name);
    					close(infile_fd);
    					close(outfile_fd);
    					exit(8);
    				}
    			} else if(bytes_read < page_size){
    				// Last iteration
    				// Write buffer to file
						bytes_write=write(outfile_fd,to,bytes_read);
    				if(DEBUG==1){
    					printf("bytes_read < page_size\n");
    					printf("bytes_write=%i\n",bytes_write);
    				}
    				if(bytes_write==-1){
    					// Maybe partial write encountered?
    					perror("Error Code 8: On <outfile> ");
    					free(infile_name);
    					free(outfile_name);
    					close(infile_fd);
    					close(outfile_fd);
    					exit(8);
    				}
    			}
    			// Clear buffers
    			memset(to,0,page_size);
    			memset(from,0,page_size);
    		} // else bytes_read == 0, terminate while
    	}
    if(stdout_bool==0){
    	printf("Saving to: %s \n",outfile_name);
    }
    ///// [---------- ENCRYPTION END ----------] /////
    
    // Both Encrypt/Decrypt OR Neither Encrypt/Decrypt
    } else {
      fprintf(stderr,"Error Code 3: Invalid execution\n");
      fprintf(stderr,"Must use EITHER Encrypt (-e) OR Decrypt (-d)\n");
      fprintf(stderr,"       i.e.  %s [-e|-d] <infile> <outfile>\n",argv[0]);
      free(infile_name);
      free(outfile_name);
      exit(3);
    }
  	free(infile_name);
  	free(outfile_name);
  	free(to);
  	free(from);
  	free(password_final);
  	close(infile_fd);
  	close(outfile_fd);
  } else{
 		fprintf(stderr,"Error Code 3: Invalid execution\n");
    fprintf(stderr,"Must include <infile> and <outfile> parameters\n");
    fprintf(stderr,"       i.e.  %s [-e|-d] <infile> <outfile>\n", argv[0]);
    exit(3);
  }
  exit(0);
}
@


1.23
log
@Doing stdin to stdout
@
text
@d57 1
a57 2
 * (NOTE: Assumes file path exists and is
 * not a directory, if it is a symlink
d66 2
a67 1
 * 5 = Unknown (symlink or directory)
d88 1
a88 2
	} else {
	// FIX THIS TO WORK RIGHT FOR FOLLOWING SYMLINKS
d91 3
d213 1
a213 1
  char rcs_vers[18] = "$Revision: 1.22 $";
d439 1
a439 1
    switch(isRegularFile(infile_name)){
d467 3
a469 3
    		default:
    			// Other (symlink or directory, unreachable with preconditions)
    			fprintf(stderr,"Error Code 7: Unknown file <infile>\n");
d504 3
a506 3
    		default:
    			// Other (symlink or directory, unreachable with preconditions)
    			fprintf(stderr,"Error Code 7: Unknown file <outfile>\n");
a612 1
    errno=0;
d614 14
a627 9
    infile_fd=open(infile_name, O_RDONLY, S_IREAD);
    if(DEBUG==1){
    	printf("infile_fd= %i \n",infile_fd);
    }
    if(infile_fd==-1){
    	perror("Error Code 8: On <infile> ");
    	free(infile_name);
    	free(outfile_name);
    	exit(8);
d630 1
a630 1
    errno=0;
d632 14
a645 9
    outfile_fd=open(outfile_name, O_WRONLY | O_CREAT | O_TRUNC | O_APPEND, S_IWRITE);
    if(DEBUG==1){
    	printf("outfile_fd= %i \n",outfile_fd);
    }
    if(outfile_fd==-1){
    	perror("Error Code 8: On <outfile> ");
    	free(infile_name);
    	free(outfile_name);
    	exit(8); 
d666 1
a666 5
    		if(stdin_bool==1){
    			bytes_read=read(STDIN_FILENO,from,page_size);
    		} else {
    			bytes_read=read(infile_fd,from,page_size);
    		}
d684 1
a684 5
    				if(stdout_bool==1){
    					bytes_write=write(STDOUT_FILENO,to,page_size);
    				} else {
    					bytes_write=write(outfile_fd,to,page_size);
    				}
d701 1
a701 5
    				if(stdout_bool==1){
    					bytes_write=write(STDOUT_FILENO,to,bytes_read);
    				} else {
    					bytes_write=write(outfile_fd,to,bytes_read);
    				}
d738 1
a738 5
    		if(stdin_bool==1){
    			bytes_read=read(STDIN_FILENO,from,page_size);
    		} else {
    			bytes_read=read(infile_fd,from,page_size);
    		}
d756 1
a756 5
    				if(stdout_bool==1){
    					bytes_write=write(STDOUT_FILENO,to,page_size);
    				} else {
							bytes_write=write(outfile_fd,to,page_size);
						}
d773 1
a773 5
    				if(stdout_bool==1){
    					bytes_write=write(STDOUT_FILENO,to,bytes_read);
    				} else {
							bytes_write=write(outfile_fd,to,bytes_read);
						}
@


1.22
log
@Fixed memory issues with key, finished encrypt/decrypt
@
text
@d58 2
a59 1
 * neither a directory or symlink)
d89 1
a194 1
  errno = 0;
d197 1
a197 1
  int DEBUG = 1;
d211 1
a211 1
  char rcs_vers[18] = "$Revision: 1.21 $";
d220 2
a221 2
  int stdin_infile;
  int stdout_outfile;
d250 1
a250 1
  stdin_infile = 0; stdout_outfile = 0;
d336 1
a336 1
/********************************* BREAKPOINT 1 ***********************************/
d340 1
a340 1
      stdin_infile=1;
d343 1
a343 1
      stdout_outfile=1;
d348 1
a348 1
    if(stdin_infile!=1){
d374 1
a374 1
/******************************** BREAKPOINT 2 ***********************************/
d377 1
a377 1
    if(stdout_outfile!=1){
a395 36
/******************************** BREAKPOINT 3 ***********************************/
    // Check if infile and outfile are the same
    sf_code = isSameFiles(infile_name, outfile_name);
    if(sf_code==1){
    	// Paths are the same references
    	fprintf(stderr,"Error Code 7: <infile> and <outfile> are the same path\n");
    	free(infile_name);
    	free(outfile_name);
    	exit(7);
    } else if(sf_code==2){
    	// Hardlinks to same file
    	fprintf(stderr,"Error Code 7: <infile> and <outfile> are hardlinks to same file\n");
    	free(infile_name);
    	free(outfile_name);
    	exit(7);
    } else if(sf_code==3){
    	// In/Out symlinks point to same file
    	fprintf(stderr,"Error Code 7: <infile> and <outfile> are symlinks to same file\n");
    	free(infile_name);
    	free(outfile_name);
    	exit(7);
    } else if(sf_code==4){
    	// Input symlink points to outfile
    	fprintf(stderr,"Error Code 7: <infile> symlink points to <outfile>\n");
    	free(infile_name);
    	free(outfile_name);
    	exit(7);
    } else if(sf_code==5){
    	// Output symlink points to infile
    	fprintf(stderr,"Error Code 7: <outfile> symlink points to <infile>\n");
    	free(infile_name);
    	free(outfile_name);
    	exit(7);
    } else{
    	// No error, continue on
    }
d397 6
a402 8
    // Check if <infile> or <outfile> is a char/block special device
    switch(isRegularFile(infile_name)){
    	case 0:
    		// Regular File
    		break;
    	case 1:
    		// Character Device
    		fprintf(stderr,"Error Code 7: <infile> is a character device\n");
d406 3
a408 3
    	case 2:
    		// Block Device
    		fprintf(stderr,"Error Code 7: <infile> is a block device\n");
d412 3
a414 3
    	case 3:
    		// FIFO - Named Pipe
    		fprintf(stderr,"Error Code 7: <infile> is a named pipe\n");
d418 3
a420 9
    	case 4:
    		// Socket
    		fprintf(stderr,"Error Code 7: <infile> is a socket\n");
    		free(infile_name);
    		free(outfile_name);
    		exit(7);
    	default:
    		// Other (symlink or directory, unreachable with preconditions)
    		fprintf(stderr,"Error Code 7: Unknown file <infile>\n");
d424 48
d473 36
a508 34
    switch(isRegularFile(outfile_name)){
    	case 0:
    		// Regular File
    		break;
    	case 1:
    		// Character Device
    		fprintf(stderr,"Error Code 7: <outfile> is a character device\n");
    		free(infile_name);
    		free(outfile_name);
    		exit(7);
    	case 2:
    		// Block Device
    		fprintf(stderr,"Error Code 7: <outfile> is a block device\n");
    		free(infile_name);
    		free(outfile_name);
    		exit(7);
    	case 3:
    		// FIFO - Named Pipe
    		fprintf(stderr,"Error Code 7: <outfile> is a named pipe\n");
    		free(infile_name);
    		free(outfile_name);
    		exit(7);
    	case 4:
    		// Socket
    		fprintf(stderr,"Error Code 7: <outfile> is a socket\n");
    		free(infile_name);
    		free(outfile_name);
    		exit(7);
    	default:
    		// Other (symlink or directory, unreachable with preconditions)
    		fprintf(stderr,"Error Code 7: Unknown file <outfile>\n");
    		free(infile_name);
    		free(outfile_name);
    		exit(7);
d517 1
a517 1
/******************************** BREAKPOINT 4 ***********************************/
d522 2
a523 2
      printf("read from stdin=%i\n",stdin_infile);
      printf("print to stdout=%i\n",stdout_outfile);
a537 1
   		// BP
d606 1
a606 1
/******************************** BREAKPOINT 5 ***********************************/
d609 1
a609 1
/******************************** BREAKPOINT 6 ***********************************/
d623 1
a623 1
/******************************** BREAKPOINT 7 ***********************************/
d636 1
a636 1
/******************************** BREAKPOINT 8 ***********************************/
d642 1
a642 5
/******************************** BREAKPOINT 9 ***********************************/
    // PERMISSIONS TEST
    chmod(infile_name,755);
    chmod(outfile_name,755);
/******************************** BREAKPOINT 10 ***********************************/
d645 7
a651 1
    	printf("Decrypting the file: %s \n",infile_name);
d654 6
a659 3
    	do {
    		bytes_read=read(infile_fd,from,page_size);
/******************************** BREAKPOINT 11 ***********************************/
a672 1
/******************************** BREAKPOINT 12 ***********************************/
d676 6
a681 3
    				// Write buffer to file
/******************************** BREAKPOINT 13 ***********************************/
    				bytes_write=write(outfile_fd,to,page_size);
a695 1
/******************************** BREAKPOINT 14 ***********************************/
d697 6
a702 2
    				// Write buffer to file
    				bytes_write=write(outfile_fd,to,bytes_read);
d721 4
a724 2
    	} while(bytes_read!=0);
    printf("Saving to: %s \n",outfile_name);
d726 1
a726 1
/******************************** BREAKPOINT 15 ***********************************/
d729 7
a735 1
    	printf("Encrypting the file: %s \n",infile_name);
d738 6
a743 3
    	do {
    		bytes_read=read(infile_fd,from,page_size);
/******************************** BREAKPOINT 16 ***********************************/
a755 1
/******************************** BREAKPOINT 17 ***********************************/
a757 1
/******************************** BREAKPOINT 18 ***********************************/
d760 6
a765 3
/******************************** BREAKPOINT 19 ***********************************/
    				// Write buffer to file
						bytes_write=write(outfile_fd,to,page_size);
a779 1
/******************************** BREAKPOINT 20 ***********************************/
d782 5
a786 1
    				bytes_write=write(outfile_fd,to,bytes_read);
d805 4
a808 2
    	} while(bytes_read!=0);
    printf("Saving to: %s \n",outfile_name);
d810 1
a810 1
/******************************** BREAKPOINT 21 ***********************************/
@


1.21
log
@Added both decryption and encryption modes
cleaned up code
@
text
@d197 1
d201 2
a202 2
  unsigned char *from = (unsigned char*)malloc(page_size);
  unsigned char *to = (unsigned char*)malloc(page_size); 
d207 4
a210 3
  char temp_buf[16];
  char temp_buf_chk[16];
  char rcs_vers[18] = "$Revision: 1.20 $";
d244 4
d335 1
a335 1
    
d348 2
a349 1
      if((fileExists(infile_name))!=1){
d355 10
a364 6
      } else if((isDirectory(infile_name))!=1){
        // <infile> DOES exist AND is a directory
        fprintf(stderr,"Error Code 6: <infile> is a directory\n");
        free(infile_name);
        free(outfile_name);
        exit(6);
d373 1
a373 1
    
d395 1
a395 1
    
d510 1
a510 1
    
d522 2
d526 12
a537 1
   		strcpy(temp_buf_chk,"\0");
d542 4
a545 2
   			strcpy(temp_buf,"\0");
   			while(strcmp(temp_buf,"\0")!=0){
d559 23
a581 13
     			strcpy(temp_buf_chk,temp_pass);
     			if(DEBUG==1){
     				printf("The 2nd password is: %s\r\n",temp_buf_chk);
     			}	
     			// Do the passwords match?
     			if(strcmp(temp_buf,temp_buf_chk)==0){
     				// Yes! :)
     				passArgNum=1;
     			} else {
     				// No :(
     				passArgNum=0;
     				fprintf(stderr,"Error: Passwords do not match, re-prompting...\n");
     			}
d585 1
d596 5
a600 1
    
d602 2
a603 2
    BF_set_key(&key, PASS_MAX, (unsigned char *)temp_buf);
    
d607 5
a611 1
    if((infile_fd=open(infile_name, O_RDONLY, S_IREAD))==-1){
d617 1
d620 5
a624 2
    if((outfile_fd=open(outfile_name, O_WRONLY | O_CREAT 
    | O_TRUNC | O_APPEND, S_IWRITE))==-1){
d630 12
a641 2
    
    // Decryption Mode
d643 1
d645 7
a651 1
    	while((bytes_read=read(infile_fd,from,page_size))!=0){
d661 3
a663 4
    			if(DEBUG==1){
    				printf("\nbytes_read=%i\n",bytes_read);
    				printf("from buffer=%s\n",from);
    			}
a665 2
    				// Encrypt the buffer
    				BF_cfb64_encrypt(from, to, page_size, &key, iv, &n, BF_DECRYPT);
d667 7
a673 1
    				if((bytes_write=write(outfile_fd,to,page_size))==-1){
d683 1
a684 2
    				// Encrypt the buffer
    				BF_cfb64_encrypt(from, to, bytes_read, &key, iv, &n, BF_DECRYPT);
d686 6
a691 1
    				if((bytes_write=write(outfile_fd,to,page_size))==-1){
d701 3
d705 5
a709 3
    	}
    
    // Encryption Mode
d711 1
d713 7
a719 1
    	while((bytes_read=read(infile_fd,from,page_size))!=0){
d729 4
a732 4
    			if(DEBUG==1){
    				printf("\nbytes_read=%i\n",bytes_read);
    				printf("from buffer=%s\n",from);
    			}
d735 1
a735 2
    				// Encrypt the buffer
    				BF_cfb64_encrypt(from, to, page_size, &key, iv, &n, BF_ENCRYPT);
d737 6
a742 1
    				if((bytes_write=write(outfile_fd,to,page_size))==-1){
d752 1
a753 2
    				// Encrypt the buffer
    				BF_cfb64_encrypt(from, to, bytes_read, &key, iv, &n, BF_ENCRYPT);
d755 6
a760 1
    				if((bytes_write=write(outfile_fd,to,page_size))==-1){
d770 3
d774 4
a777 2
    	}	
    	
d789 5
@


1.20
log
@Added encryption part
@
text
@d13 1
d18 1
d22 7
a28 1
  return (stat(fName, &buf)==0);
a196 1
  int i = 0; // General purpose index
d208 1
a208 1
  char rcs_vers[18] = "$Revision: 1.19 $";
a328 1
		// FREE INFILE_NAME AND OUTFILE_NAME AT ALL RETURNS
a355 9
      	// Check permissions and file type of <infile>
      	errno=0;
      	infile = fopen(infile_name,"r");
      	if(errno != 0){
      		perror("Error Code 8: On <infile>");
      		free(infile_name);
      		free(outfile_name);
      		exit(8);
      	}
d368 2
a369 9
    		// Check permissions of creating <outfile>
    		errno=0;
    		outfile = fopen(outfile_name,"w");
    		if((outfile==NULL) || (errno !=0)){
    			perror("Error Code 8: On <outfile>");
    			free(infile_name);
    			free(outfile_name);
    			exit(8);
    		}
a377 1
    		// Check permissions and file type of <outfile>
a378 8
    		errno=0;
    		outfile = fopen(outfile_name, "w");
    		if(errno != 0){
    			perror("Error Code 8: On <outfile>");
    			free(infile_name);
    			free(outfile_name);
    			exit(8);
    		}
d408 1
a408 5
    	free(infile_name);if(bytes_read!=page_size){
    			
    			} else {
    			
    			}
d561 1
a561 1
    BF_set_key(&key, PASS_MAX, temp_buf);
d563 1
d565 1
a565 1
    // Open up infile
d573 1
a573 1
    // Open up outfile
d584 46
a629 2
    /* Decrypting is the same: just pass BF_DECRYPT instead */
    BF_cfb64_encrypt(from, to, page_size, &key, iv, &n, BF_DECRYPT);
d634 1
a634 1
    	while((bytes_read=read(infile_fd,from,page_size)!=0){
d648 13
a660 28
    			// Encrypt the buffer
    			BF_cfb64_encrypt(from, to, page_size, &key, iv, &n, BF_ENCRYPT);
    			// Write buffer to file
    			if((bytes_write=write(outfile_fd,to,page_size))==-1){
    				// Maybe partial write encountered?
    				perror("Error Code 8: On <outfile> ");
    				free(infile_name);
    				free(outfile_name);
    				close(infile_fd);
    				close(outfile_fd);
    				exit(8);
    			}
    			// Was it uneven?
    			if(bytes_read < page_size){
    				// Last iteration:
    				// (page_size)-(bytes_read) = number of padded zeros at end
    				// Write bytes to end of file in ASCII 
    				i=bytes_read;
    				while(i-256>=256){
    					if((bytes_write=write(outfile_fd,(unsigned char)(255), 1)==-1){
    						perror("Error Code 8: On <outfile> ");
    						free(infile_name);
    						free(outfile_name);
    						close(infile_fd);
    						close(outfile_fd);
    						exit(8);
    					}
    					i=i-256;
d662 8
a669 2
						if((bytes_write=write(outfile_fd,(unsigned char)(i),1)==-1){
							perror("Error Code 8: On <outfile> ");
d675 1
a675 1
						}
d677 2
a678 3
    		}
    		// else bytes_read == 0, terminate loop
    	}
@


1.19
log
@More stuff
@
text
@d9 1
d185 1
d189 1
a189 1
  errno = 0;
d192 3
a194 2
  //int PAGE_SIZE=getpagesize();
  //char from[PAGE_SIZE], to[PAGE_SIZE];
d201 1
a201 1
  char rcs_vers[18] = "$Revision: 1.18 $";
d206 2
a207 2
  FILE *infile;
  FILE *outfile;
d213 2
a214 1
  int len;
d218 5
d224 1
a224 1
  // BF_KEY key;
d232 3
a235 1
  len = 128;
d427 5
a431 1
    	free(infile_name);
d581 22
d606 2
d611 57
a667 1
    
d676 1
a676 22
    }	

    /* don't worry about these two: just define/use them */
    // int n = 0;  /* internal blowfish variables */
    // unsigned char iv[8];  /* Initialization Vector */

    /* fill the IV with zeros (or any other fixed data) */
    // memset(iv, 0, 8);

    /* call this function once to setup the cipher key */
    // BF_set_key(&key, 16, temp_buf);

    /*
     * This is how you encrypt an input char* buffer "from", of length "len"
     * onto output buffer "to", using key "key".  Just pass "iv" and "&n" as
     * shown, and don't forget to actually tell the function to BF_ENCRYPT.
     */
    // BF_cfb64_encrypt(from, to, len, &key, iv, &n, BF_ENCRYPT);

    /* Decrypting is the same: just pass BF_DECRYPT instead */
    // BF_cfb64_encrypt(from, to, len, &key, iv, &n, BF_DECRYPT);
  	
@


1.18
log
@Added password checking
@
text
@d194 2
a195 1
  char *temp_pass;
d198 1
a198 1
  char rcs_vers[18] = "$Revision: 1.17 $";
d248 12
a259 6
      strcpy(temp_buf, optarg);
      // Gets argc number from optind for comparison
      //  and error checking later
      passArgNum = optind-1;
      pass = 1;
      break;
d540 2
a541 9
     			strcpy(temp_buf_chk,"\0");
     			while(strcmp(temp_buf,"\0")!=0){
     				temp_pass = getpass("Confirm Password: ");
     				if((unsigned)strlen(temp_pass) <= 16){
     					strcpy(temp_buf,temp_pass);
     				} else {
     					fprintf(stderr,"Error: Password cannot be longer than 16 characters\n");
     				}
     			}
@


1.17
log
@Fixed formatting
@
text
@d194 1
d197 1
a197 1
  char rcs_vers[18] = "$Revision: 1.16 $";
d256 1
a256 1
      return 3;
d264 1
a264 1
    printf("\ndecode=%i \nencode=%i \nversion=%i \nhelp=%i \nmmap=%i \npass=%i \n", deco, enco, vers, help, mmap, pass);
d274 1
a274 1
  
d282 1
a282 1
    printf("   -v        :  Print out version number \n");
d286 1
a286 1
    return 1;
d289 1
a289 1
    return 2;
d297 1
a297 1
      return 4;
d323 1
a323 1
        return 5;
d329 1
a329 1
        return 6;
d339 1
a339 1
      		return 8;
d360 1
a360 1
    			return 8;
d367 1
a367 1
    		return 6;
d378 1
a378 1
    			return 8;
d393 1
a393 1
    	return 7;
d399 1
a399 1
    	return 7;
d405 1
a405 1
    	return 7;
d411 1
a411 1
    	return 7;
d417 1
a417 1
    	return 7;
d432 1
a432 1
    		return 7;
d438 1
a438 1
    		return 7;
d444 1
a444 1
    		return 7;
d450 1
a450 1
    		return 7;
d456 1
a456 1
    		return 7;
d467 1
a467 1
    		return 7;
d473 1
a473 1
    		return 7;
d479 1
a479 1
    		return 7;
d485 1
a485 1
    		return 7;
d491 1
a491 1
    		return 7;
d510 2
d515 44
a558 4
   	} else if(pass==0 && safe==1){
   		// Ask for password twice
   	} else if(pass==0 && safe==0){
     	// Ask for password once
d561 4
d578 3
a580 1
      return 3;
d602 1
d609 1
a609 1
    return 3;
d611 1
a611 1
  return 0;
@


1.16
log
@Debugged
@
text
@d196 1
a196 1
  char rcs_vers[18] = "$Revision: 1.15 $";
d508 11
d522 1
a522 10
      if(pass==1 && safe==0){
        // temp_buf has password
      	strcpy(temp_buf_chk,"\0"); // Now unused
      } else if(pass==0 && safe==1){
        // Ask for password twice
      } else if(pass==0 && safe==0){
      	// Ask for password once
      } else{
      	// Error both -p and -s given
      }
d525 1
a525 10
    	if(pass==1 && safe==0){
    		// temp_buf as password
    		strcpy(temp_buf_chk,"\0"); // Now unused
    	} else if(pass==0 && safe==1){
    		// Ask for password twice
    	} else if(pass==0 && safe==0){
    		// Ask for password once
    	} else {
    		// Error both -p and -s given
    	}
@


1.15
log
@Finished all file i/o checking
@
text
@d18 2
a19 2
  struct stat buffer;
  return (stat(fName, &buffer)==0);
d27 1
d30 8
a37 4
  struct stat buf;
  buf = malloc(sizeof(struct stat));
  stat(path,&buffer);
  if(buffer.st_mode & S_IFDIR){
d60 4
a63 4
	struct stat buf;
	buf = malloc(sizeof(struct stat));
	stat(path,&buf);
	if(buf.st_mode & S_ISREG){
d66 1
a66 1
	} else if(buf.st_mode & S_ISCHR){
d69 1
a69 1
	} else if(buf.st_mode & S_ISBLK){
d72 1
a72 1
	} else if(buf.st_mode & S_ISFIFO){
d75 1
a75 1
	} else if(buf.st_mode & S_ISSOCK){
d97 6
a102 6
	struct stat in_buffer;
	struct stat out_buffer;
	in_buffer = malloc(sizeof(struct stat));
	out_buffer = malloc(sizeof(struct stat));
	stat(in_path,&in_buffer);
	stat(out_path,&out_buffer);
d109 4
a112 3
		lstat(in_path,&in_buffer);
		lstat(out_path,&out_buffer);
		if(!(in_buffer.st_mode & S_IFLNK) && !(out_buffer.st_mode & S_IFLNK)){
d115 2
a116 1
			if((in_buffer.st_dev==out_buffer.st_dev) && (in_buffer.st_ino==out_buffer.st_ino)){
d125 2
a126 1
		} else if((in_buffer.st_mode & S_IFLNK) && (out_buffer.st_mode & S_IFLNK)){
d129 4
a132 3
			stat(in_path,&in_buffer);
			stat(out_path,&out_buffer);
			if((in_buffer.st_dev==out_buffer.st_dev) && (in_buffer.st_ino==out_buffer.st_ino)){
d139 2
a140 1
		} else if((in_buffer.st_mode & S_IFLNK) && !(out_buffer.st_mode & S_IFLNK)){
d143 4
a146 3
			stat(in_path,&in_buffer);
			stat(out_path,&in_buffer);
			if((in_buffer.st_dev==out_buffer.st_dev) && (in_buffer.st_ino==out_buffer.st_ino)){
d156 4
a159 3
			stat(in_path,&in_buffer);
			stat(out_path,&out_buffer);
			if((in_buffer.st_dev==out_buffer.st_dev) && (in_buffer.st_ino==out_buffer.st_ino)){
d195 2
a196 2
  //char temp_buf_chk[16];
  char rcs_vers[18] = "$Revision: 1.14 $";
d353 1
a353 1
    		errno=0
d422 1
a422 1
    switch(isRegularFile(infile_name){
d498 1
a498 2
    //		than <infile>, else it is not a link but a regular file.
    
d511 1
a511 2
      // Password in cmd arg
      if(pass==1){
d513 5
a517 1
        
d519 1
a519 7
        if(safe==1){
          // Ask for password twice
          
        } else{
          // Ask for password once
          
        }
d523 10
a532 12
      // Password in the cmd arg
      if(pass==1){
        // temp_buf has password
      } else{
        if(safe==1){
          // Ask for password twice
          
        } else{
          // Ask for password once
          
        }
      }
@


1.14
log
@More work on file i/o error checking
@
text
@d29 2
a30 1
  struct stat buffer;
d33 1
d36 1
d41 38
d94 2
d100 1
d110 1
d115 1
d124 1
d127 1
d136 1
d139 1
d148 1
d151 1
d184 1
a184 1
  char rcs_vers[18] = "$Revision: 1.13 $";
d272 1
a272 1
    printf("   -s        :  Safe Mode (prompt for password twice\n");
d291 1
a291 1
    // MAKE SURE TO FREE THESE
d358 9
d370 1
a370 1
    // <outfile> IS NOT a directory
a373 1
    // (NOTE: Assumes both files exist)
d404 1
d410 71
a480 6
    
    // Check if current user contains permissions for both files
    
    
    
    //	Preconditions: 
d482 2
a483 2
    //		symlink/hardlink, it points to a seperate file than 
    //		<outfile>, else it is not a link but a regular file.
d485 2
a486 2
    //		symlink/hardlink, it points to a seperate file than
    //		<infile>, else it is not a link but a regular file	 
d554 2
a555 1
  
@


1.13
log
@Added more error checking with permissions and file i/o (unfinished)
@
text
@a37 9
/* Handles checking the permissions of any
 * given file.  
 * SUCCESS CODE(S):
 * 0 = 
 */
int chkPermissions(char *file){
	
}

d132 1
a132 1
  char rcs_vers[18] = "$Revision: 1.12 $";
d289 8
@


1.12
log
@Completed same file error checking
@
text
@d8 1
d38 11
a48 1
/* Handles checking if two files are the same
d124 1
a124 1
 * 6 = <infile> is a directory
d126 1
d132 3
d141 1
a141 1
  char rcs_vers[18] = "$Revision: 1.11 $";
d146 2
d155 1
a155 1
  /* define boolean ints for params */
d157 1
a157 1
  /* define a structure to hold the key */
d166 1
a166 1
  /* initialize and check params */
d259 2
a260 1
    // Checks for if the infile exists or is directory
d263 1
d268 2
a269 2
      }
      else if((isDirectory(infile_name))!=1){
d274 11
d287 25
d314 1
d349 2
d354 10
@


1.11
log
@Versioning parsing completed
@
text
@d110 1
a110 1
 * 3 = Invalid command-line args given
d114 1
d126 1
a126 1
  char rcs_vers[18] = "$Revision: 1.10 $";
d135 1
d147 1
d181 2
a182 1
      fprintf(stderr, "Usage: %s [OPTIONS] [-p PASSWORD] <infile> <outfile>\n", argv[0]);
d223 1
a223 1
      fprintf(stderr,"Error: No outfile specified\n");
d231 1
a231 1
    // MAKE SURE TO FREE THIS
d245 1
a245 1
        fprintf(stderr,"Error: Input file does not exist\n");
d251 1
a251 1
        fprintf(stderr,"Error: Input file is a directory\n");
d258 36
a293 1
    // Checks for infile and outfile being the same
d336 4
a339 3
      fprintf(stderr, "Error: Must use EITHER Encrypt (-e) OR Decrypt (-d)\n");
      fprintf(stderr, "       i.e.  %s [-e|-d] <infile> <outfile>\n",argv[0]);
      return 0;
d363 2
a364 1
    fprintf(stderr,"Error: Must include <infile> and <outfile> parameters\n");
d366 1
a366 1
    return 0;
@


1.10
log
@Adding parsing for version
@
text
@a1 1
#include <unistd.h>
d3 1
d125 2
a126 1
  char *version = "$Revision: 1.9 $";
d140 6
a145 1

d211 1
a211 1
    printf("Blowfish Cipher Tool - %s\n", version);
@


1.9
log
@Fixed syntax of error checking for same files
@
text
@d104 2
a105 2
/* [-------- Main Method --------] */
/* SUCCESS CODE(S):
d125 1
a125 1
  char *version = "$Revision: 1.8 $";
@


1.8
log
@Added error checking for same files
@
text
@d10 6
d21 6
d39 8
a46 2
 * ERROR CODES:
 * 
d51 2
a52 2
	stat(in_path,in_buffer);
	stat(out_path,out_buffer);
d55 1
a55 6
		// Checks DeviceID and Inode numbers for exact match
		if((in_buffer.st_dev==out_buffer.st_dev) && (in_buffer.rdev==out_buffer.rdev)){
			return 1;
		} else {
			return 0;
		}
d58 3
a60 3
		lstat(in_path,in_buffer);
		lstat(out_path,out_buffer);
		if(!(in_buffer.st_mode & S_IFLNK) && !(out_buffer.st_mode & S_IFLINK)){
d63 2
a64 2
			if((in_buffer.st_dev==out_buffer.st_dev) && (in_buffer.st_rdev==out_buffer.st_rdev)){
				return 1;
d73 4
a76 4
			stat(in_path,in_buffer);
			stat(out_path,out_buffer);
			if((in_buffer.st_dev==out_buffer.st_dev) && (in_buffer.st_rdev==out_buffer.st_rdev)){
				return 1;
d83 4
a86 4
			stat(in_path,in_buffer);
			stat(out_path,in_buffer);
			if((in_buffer.st_dev==out_buffer.st_dev) && (in_buffer.st_rdev==out_buffer.st_rdev)){
				return 1;
d93 4
a96 4
			stat(in_path,in_buffer);
			stat(out_path,out_buffer);
			if((in_buffer.st_dev==out_buffer.st_dev) && (in_buffer.st_rdev==out_buffer.st_dev)){
				return 1;
d104 11
d119 1
a119 1
  int PAGE_SIZE=getpagesize();
d125 1
a125 1
  char *version = "$Revision: 1.7 $";
d173 1
a173 1
      return 0;
d203 1
a203 1
    return 0;
d206 1
a206 1
    return 0;
d214 1
a214 1
      return 0;
d217 2
a218 2
    infile_name=(char*)malloc(sizeof(char)*strlen(argv[argc-2]));
    outfile_name=(char*)malloc(sizeof(char)*strlen(argv[argc-1]));
d238 1
a238 1
        return 0;
d244 1
a244 1
        return 0;
@


1.7
log
@Even more error checking
@
text
@d25 66
d95 2
a96 2

  //char from[128], to[128];
d101 1
a101 1
  char *version = "$Revision: 1.6 $";
d104 1
a104 1
  /* File names/descriptors/stats*/
d149 1
a149 1
      exit(EXIT_FAILURE);
d196 2
a197 1
    strcpy(infile_name, argv[argc-2]);
d208 1
d212 2
d218 2
d224 3
d284 1
a284 1
     * onto output buffer "to", using key "key".  Jyst pass "iv" and "&n" as
@


1.6
log
@Included more error checking for input and output files
@
text
@a0 1

d15 10
d26 2
d35 3
a37 1
  char *version = "$Revision: 1.5 $";
d76 3
d89 2
d94 1
a94 1
      printf("\ntemp_buf=%s\n",temp_buf);
d96 1
a96 1
      printf("\ntemp_buf=<BLANK>\n");
d118 8
d146 4
@


1.5
log
@Added reading infile name and outfile name
@
text
@d1 1
d6 3
d11 5
d24 2
a25 1
  char *version = "$Revision: 1.4 $";
d28 2
d39 1
d71 1
d80 1
d82 2
a83 1

d95 1
d98 2
a99 1
  } else{
d105 18
d126 2
d129 2
d139 2
a140 1
      
d142 2
a143 1
      
d153 2
a154 1

d156 2
a157 1

d163 2
d187 4
@


1.4
log
@AAdded functionality
@
text
@d14 4
a17 1
  char *version = "$Revision: 1.3 $";
d21 1
a21 1
  int deco, enco, vers, help, mmap, pass, opt;
d27 2
a28 2
  deco = 0; enco = 0; vers = 0; help = 0; mmap = 0; pass = 0;
  while((opt = getopt(argc, argv, "devhmp:")) != -1) {
d45 3
d78 1
d82 10
d93 12
a104 2


d106 11
a116 2


d120 1
@


1.3
log
@Added new error checking .
@
text
@d14 1
a14 1
  char *version = "$Revision: 1.2 $";
d82 1
a82 1
      printf("Error: Must use ONLY Encrypt (-e) OR Decrypt (-d)\n");
a103 1
    return 0;
d105 1
@


1.2
log
@Add help menu.
@
text
@d14 1
a14 1
  char *version = "$Revision$";
d73 27
a99 19
    printf("Blowfish Cipher Tool - Version: %s\n", version);
  }
  
  /* don't worry about these two: just define/use them */
  // int n = 0;  /* internal blowfish variables */
  // unsigned char iv[8];  /* Initialization Vector */

  /* fill the IV with zeros (or any other fixed data) */
  // memset(iv, 0, 8);

  /* call this function once to setup the cipher key */
  // BF_set_key(&key, 16, temp_buf);

  /*
   * This is how you encrypt an input char* buffer "from", of length "len"
   * onto output buffer "to", using key "key".  Jyst pass "iv" and "&n" as
   * shown, and don't forget to actually tell the function to BF_ENCRYPT.
   */
  // BF_cfb64_encrypt(from, to, len, &key, iv, &n, BF_ENCRYPT);
d101 2
a102 2
  /* Decrypting is the same: just pass BF_DECRYPT instead */
  // BF_cfb64_encrypt(from, to, len, &key, iv, &n, BF_DECRYPT);
d104 2
a105 1
  return 0;
@


1.1
log
@Initial revision
@
text
@d47 1
a47 1
      fprintf(stderr, "Usage: %s [-devhm] [-p PASSWORD] <infile> <outfile>\n", argv[0]);
d63 9
a71 1
    
@
